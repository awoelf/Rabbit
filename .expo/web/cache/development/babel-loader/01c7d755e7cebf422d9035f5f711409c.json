{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nimport React, { Component } from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport I18nManager from \"react-native-web/dist/exports/I18nManager\";\nimport { PanGestureHandler, TapGestureHandler, State } from 'react-native-gesture-handler';\nimport { Constants } from \"../../commons/new\";\nimport { HapticService, HapticType } from \"../../services\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nvar DRAG_TOSS = 0.05;\nvar LEFT_TOGGLE_THRESHOLD = 0.6;\nif (!Math.sign) {\n  Math.sign = function (x) {\n    return Number(x > 0) - Number(x < 0) || +x;\n  };\n}\nvar Swipeable = function (_Component) {\n  _inherits(Swipeable, _Component);\n  var _super = _createSuper(Swipeable);\n  function Swipeable(props) {\n    var _this;\n    _classCallCheck(this, Swipeable);\n    _this = _super.call(this, props);\n    _this._triggerHaptic = function () {\n      return !_this.props.disableHaptic && HapticService.triggerHaptic(HapticType.impactMedium, 'Drawer');\n    };\n    _this._handleDrag = function (e) {\n      var onToggleSwipeLeft = _this.props.onToggleSwipeLeft;\n      if (onToggleSwipeLeft) {\n        var _this$state = _this.state,\n          rowWidth = _this$state.rowWidth,\n          leftWidth = _this$state.leftWidth;\n        var x = e.nativeEvent.translationX;\n        var threshold = rowWidth * LEFT_TOGGLE_THRESHOLD;\n        if (!_this.dragThresholdReached && x >= threshold && x < threshold + 10) {\n          _this.dragThresholdReached = true;\n          _this._triggerHaptic();\n          onToggleSwipeLeft({\n            rowWidth: rowWidth,\n            leftWidth: leftWidth,\n            dragX: x\n          });\n        }\n        if (_this.dragThresholdReached && x < threshold - 10) {\n          _this.dragThresholdReached = false;\n          onToggleSwipeLeft({\n            rowWidth: rowWidth,\n            leftWidth: leftWidth,\n            dragX: x,\n            resetItemPosition: true\n          });\n        }\n      }\n    };\n    _this.getTransX = function () {\n      var _this$props = _this.props,\n        friction = _this$props.friction,\n        overshootFriction = _this$props.overshootFriction;\n      var _this$state2 = _this.state,\n        dragX = _this$state2.dragX,\n        rowTranslation = _this$state2.rowTranslation,\n        _this$state2$leftWidt = _this$state2.leftWidth,\n        leftWidth = _this$state2$leftWidt === void 0 ? 0 : _this$state2$leftWidt,\n        _this$state2$rowWidth = _this$state2.rowWidth,\n        rowWidth = _this$state2$rowWidth === void 0 ? 0 : _this$state2$rowWidth;\n      var _this$state$rightOffs = _this.state.rightOffset,\n        rightOffset = _this$state$rightOffs === void 0 ? rowWidth : _this$state$rightOffs;\n      var rightWidth = Math.max(0, rowWidth - rightOffset);\n      var _this$props2 = _this.props,\n        _this$props2$overshoo = _this$props2.overshootLeft,\n        overshootLeft = _this$props2$overshoo === void 0 ? leftWidth > 0 : _this$props2$overshoo,\n        _this$props2$overshoo2 = _this$props2.overshootRight,\n        overshootRight = _this$props2$overshoo2 === void 0 ? rightWidth > 0 : _this$props2$overshoo2;\n      var transX = Animated.add(rowTranslation, dragX.interpolate({\n        inputRange: [0, friction],\n        outputRange: [0, 1]\n      })).interpolate({\n        inputRange: [-rightWidth - (overshootRight ? 1 : overshootFriction), -rightWidth, leftWidth, leftWidth + (overshootLeft ? 1 : overshootFriction)],\n        outputRange: [-rightWidth - (overshootRight || overshootFriction > 1 ? 1 : 0), -rightWidth, leftWidth, leftWidth + (overshootLeft || overshootFriction > 1 ? 1 : 0)]\n      });\n      return transX;\n    };\n    _this.getShowLeftAction = function () {\n      var transX = _this.getTransX();\n      var _this$state$leftWidth = _this.state.leftWidth,\n        leftWidth = _this$state$leftWidth === void 0 ? 0 : _this$state$leftWidth;\n      var showLeftAction = leftWidth > 0 ? transX.interpolate({\n        inputRange: [-1, 0, leftWidth],\n        outputRange: [0, 0, 1]\n      }) : new Animated.Value(0);\n      return showLeftAction;\n    };\n    _this.getLeftActionTranslate = function () {\n      var showLeftAction = _this.getShowLeftAction();\n      var leftActionTranslate = showLeftAction.interpolate({\n        inputRange: [0, Number.MIN_VALUE],\n        outputRange: [-10000, 0],\n        extrapolate: 'clamp'\n      });\n      return leftActionTranslate;\n    };\n    _this.getShowRightAction = function () {\n      var transX = _this.getTransX();\n      var _this$state$rowWidth = _this.state.rowWidth,\n        rowWidth = _this$state$rowWidth === void 0 ? 0 : _this$state$rowWidth;\n      var _this$state$rightOffs2 = _this.state.rightOffset,\n        rightOffset = _this$state$rightOffs2 === void 0 ? rowWidth : _this$state$rightOffs2;\n      var rightWidth = Math.max(0, rowWidth - rightOffset);\n      var showRightAction = rightWidth > 0 ? transX.interpolate({\n        inputRange: [-rightWidth, 0, 1],\n        outputRange: [1, 0, 0]\n      }) : new Animated.Value(0);\n      return showRightAction;\n    };\n    _this.getRightActionTranslate = function () {\n      var showRightAction = _this.getShowRightAction();\n      var rightActionTranslate = showRightAction.interpolate({\n        inputRange: [0, Number.MIN_VALUE],\n        outputRange: [-10000, 0],\n        extrapolate: 'clamp'\n      });\n      return rightActionTranslate;\n    };\n    _this._onTapHandlerStateChange = function (_ref) {\n      var nativeEvent = _ref.nativeEvent;\n      if (_this.rowState !== 0) {\n        if (nativeEvent.oldState === State.ACTIVE) {\n          _this.close();\n        }\n      }\n    };\n    _this._onHandlerStateChange = function (_ref2) {\n      var nativeEvent = _ref2.nativeEvent;\n      if (nativeEvent.oldState === State.ACTIVE) {\n        _this._handleRelease(nativeEvent);\n      }\n      if (nativeEvent.state === State.ACTIVE) {\n        _this.props.onDragStart && _this.props.onDragStart(_this.props);\n      }\n    };\n    _this._hasLeftActions = _this.props.renderLeftActions !== undefined;\n    _this._hasRightActions = _this.props.renderRightActions !== undefined;\n    _this._handleRelease = function (nativeEvent) {\n      var velocityX = nativeEvent.velocityX,\n        dragX = nativeEvent.translationX;\n      var _this$state3 = _this.state,\n        _this$state3$leftWidt = _this$state3.leftWidth,\n        leftWidth = _this$state3$leftWidt === void 0 ? 0 : _this$state3$leftWidt,\n        _this$state3$rowWidth = _this$state3.rowWidth,\n        rowWidth = _this$state3$rowWidth === void 0 ? 0 : _this$state3$rowWidth;\n      var _this$state$rightOffs3 = _this.state.rightOffset,\n        rightOffset = _this$state$rightOffs3 === void 0 ? rowWidth : _this$state$rightOffs3;\n      var rightWidth = rowWidth - rightOffset;\n      var _this$props3 = _this.props,\n        fullSwipeLeft = _this$props3.fullSwipeLeft,\n        fullSwipeRight = _this$props3.fullSwipeRight,\n        friction = _this$props3.friction,\n        _this$props3$leftThre = _this$props3.leftThreshold,\n        leftThreshold = _this$props3$leftThre === void 0 ? leftWidth / 2 : _this$props3$leftThre,\n        _this$props3$rightThr = _this$props3.rightThreshold,\n        rightThreshold = _this$props3$rightThr === void 0 ? rightWidth / 2 : _this$props3$rightThr,\n        fullLeftThreshold = _this$props3.fullLeftThreshold,\n        fullRightThreshold = _this$props3.fullRightThreshold,\n        onToggleSwipeLeft = _this$props3.onToggleSwipeLeft;\n      var startOffsetX = _this._currentOffset() + dragX / friction;\n      var translationX = (dragX + DRAG_TOSS * velocityX) / friction;\n      var toValue = 0;\n      if (_this.rowState === 0) {\n        if (Constants.isRTL && _this._hasLeftActions && onToggleSwipeLeft && translationX < -(rowWidth * LEFT_TOGGLE_THRESHOLD) && !_this.dragThresholdReached) {\n          toValue = -(rowWidth * LEFT_TOGGLE_THRESHOLD);\n        } else if (_this._hasLeftActions && onToggleSwipeLeft && translationX > rowWidth * LEFT_TOGGLE_THRESHOLD && !_this.dragThresholdReached) {\n          toValue = rowWidth * LEFT_TOGGLE_THRESHOLD;\n        } else if (!onToggleSwipeLeft && fullSwipeLeft && translationX > rowWidth * fullLeftThreshold) {\n          _this._triggerHaptic();\n          toValue = rowWidth;\n        } else if (_this._hasRightActions && fullSwipeRight && translationX < -rowWidth * fullRightThreshold) {\n          _this._triggerHaptic();\n          toValue = -rowWidth;\n        } else if (_this._hasLeftActions && translationX > leftThreshold) {\n          if (!onToggleSwipeLeft || onToggleSwipeLeft && translationX < rowWidth * LEFT_TOGGLE_THRESHOLD) {\n            toValue = leftWidth;\n          }\n        } else if (_this._hasRightActions && translationX < -rightThreshold) {\n          toValue = -rightWidth;\n        }\n      } else if (_this.rowState === 1) {\n        if (translationX > -leftThreshold) {\n          toValue = leftWidth;\n        }\n      } else {\n        if (translationX < rightThreshold) {\n          toValue = -rightWidth;\n        }\n      }\n      _this._animateRow(startOffsetX, toValue, velocityX / friction);\n    };\n    _this._animateRow = function (fromValue, toValue, velocityX) {\n      var _this$state4 = _this.state,\n        dragX = _this$state4.dragX,\n        rowTranslation = _this$state4.rowTranslation,\n        rowWidth = _this$state4.rowWidth,\n        leftWidth = _this$state4.leftWidth;\n      var _this$props4 = _this.props,\n        useNativeAnimations = _this$props4.useNativeAnimations,\n        animationOptions = _this$props4.animationOptions,\n        onSwipeableLeftOpen = _this$props4.onSwipeableLeftOpen,\n        onSwipeableRightOpen = _this$props4.onSwipeableRightOpen,\n        onSwipeableClose = _this$props4.onSwipeableClose,\n        onSwipeableOpen = _this$props4.onSwipeableOpen,\n        onSwipeableLeftWillOpen = _this$props4.onSwipeableLeftWillOpen,\n        onSwipeableRightWillOpen = _this$props4.onSwipeableRightWillOpen,\n        onSwipeableWillClose = _this$props4.onSwipeableWillClose,\n        onSwipeableWillOpen = _this$props4.onSwipeableWillOpen,\n        onFullSwipeLeft = _this$props4.onFullSwipeLeft,\n        onToggleSwipeLeft = _this$props4.onToggleSwipeLeft,\n        onWillFullSwipeLeft = _this$props4.onWillFullSwipeLeft,\n        onFullSwipeRight = _this$props4.onFullSwipeRight,\n        onWillFullSwipeRight = _this$props4.onWillFullSwipeRight;\n      dragX.setValue(0);\n      rowTranslation.setValue(fromValue);\n      _this.rowState = Math.sign(toValue);\n      Animated.spring(rowTranslation, _objectSpread({\n        toValue: toValue,\n        restSpeedThreshold: 1.7,\n        restDisplacementThreshold: 0.4,\n        velocity: velocityX,\n        bounciness: 0,\n        useNativeDriver: useNativeAnimations\n      }, animationOptions)).start(function (_ref3) {\n        var finished = _ref3.finished;\n        if (finished) {\n          if (toValue === rowWidth && onFullSwipeLeft) {\n            onFullSwipeLeft();\n          } else if (toValue === -rowWidth && onFullSwipeRight) {\n            onFullSwipeRight();\n          } else if (toValue > 0 && onSwipeableLeftOpen) {\n            onSwipeableLeftOpen();\n          } else if (toValue < 0 && onSwipeableRightOpen) {\n            onSwipeableRightOpen();\n          }\n          if (toValue === 0) {\n            onSwipeableClose && onSwipeableClose();\n          } else {\n            onSwipeableOpen && onSwipeableOpen();\n          }\n        }\n      });\n      if (Constants.isRTL && _this._hasLeftActions && onToggleSwipeLeft && (toValue === -(rowWidth * LEFT_TOGGLE_THRESHOLD) || _this.dragThresholdReached)) {\n        onToggleSwipeLeft({\n          rowWidth: rowWidth,\n          leftWidth: leftWidth,\n          released: true,\n          triggerHaptic: !_this.dragThresholdReached\n        });\n      } else if (_this._hasLeftActions && onToggleSwipeLeft && (toValue === rowWidth * LEFT_TOGGLE_THRESHOLD || _this.dragThresholdReached)) {\n        onToggleSwipeLeft({\n          rowWidth: rowWidth,\n          leftWidth: leftWidth,\n          released: true,\n          triggerHaptic: !_this.dragThresholdReached\n        });\n        _this.dragThresholdReached = false;\n      } else if (toValue === rowWidth && onWillFullSwipeLeft) {\n        onWillFullSwipeLeft();\n      } else if (toValue === -rowWidth && onWillFullSwipeRight) {\n        onWillFullSwipeRight();\n      } else if (toValue > 0 && onSwipeableLeftWillOpen) {\n        onSwipeableLeftWillOpen();\n      } else if (toValue < 0 && onSwipeableRightWillOpen) {\n        onSwipeableRightWillOpen();\n      }\n      if (toValue === 0) {\n        onSwipeableWillClose && onSwipeableWillClose();\n      } else {\n        onSwipeableWillOpen && onSwipeableWillOpen();\n      }\n    };\n    _this._currentOffset = function () {\n      var _this$state5 = _this.state,\n        _this$state5$leftWidt = _this$state5.leftWidth,\n        leftWidth = _this$state5$leftWidt === void 0 ? 0 : _this$state5$leftWidt,\n        _this$state5$rowWidth = _this$state5.rowWidth,\n        rowWidth = _this$state5$rowWidth === void 0 ? 0 : _this$state5$rowWidth;\n      var _this$state$rightOffs4 = _this.state.rightOffset,\n        rightOffset = _this$state$rightOffs4 === void 0 ? rowWidth : _this$state$rightOffs4;\n      var rightWidth = rowWidth - rightOffset;\n      if (_this.rowState === 1) {\n        return leftWidth;\n      } else if (_this.rowState === -1) {\n        return -rightWidth;\n      }\n      return 0;\n    };\n    _this.close = function () {\n      _this._animateRow(_this._currentOffset(), 0);\n    };\n    _this.openLeft = function () {\n      var _this$state$leftWidth2 = _this.state.leftWidth,\n        leftWidth = _this$state$leftWidth2 === void 0 ? 0 : _this$state$leftWidth2;\n      _this._animateRow(_this._currentOffset(), leftWidth);\n    };\n    _this.openLeftFull = function () {\n      if (_this._hasLeftActions) {\n        var rowWidth = _this.state.rowWidth;\n        _this._animateRow(_this._currentOffset(), rowWidth);\n      }\n    };\n    _this.toggleLeft = function () {\n      var shouldAnimate = Constants.isRTL ? _this._hasRightActions : _this._hasLeftActions;\n      if (shouldAnimate) {\n        var rowWidth = _this.state.rowWidth;\n        _this._animateRow(_this._currentOffset(), rowWidth * LEFT_TOGGLE_THRESHOLD * (Constants.isRTL ? -1 : 1));\n      }\n    };\n    _this.openRight = function () {\n      var _this$state$rowWidth2 = _this.state.rowWidth,\n        rowWidth = _this$state$rowWidth2 === void 0 ? 0 : _this$state$rowWidth2;\n      var _this$state$rightOffs5 = _this.state.rightOffset,\n        rightOffset = _this$state$rightOffs5 === void 0 ? rowWidth : _this$state$rightOffs5;\n      var rightWidth = rowWidth - rightOffset;\n      _this._animateRow(_this._currentOffset(), -rightWidth);\n    };\n    _this.openRightFull = function () {\n      if (_this._hasRightActions) {\n        var rowWidth = _this.state.rowWidth;\n        _this._animateRow(_this._currentOffset(), -rowWidth);\n      }\n    };\n    _this._onRowLayout = function (_ref4) {\n      var nativeEvent = _ref4.nativeEvent;\n      return _this.handleMeasure('rowWidth', nativeEvent);\n    };\n    _this._onLeftLayout = function (_ref5) {\n      var nativeEvent = _ref5.nativeEvent;\n      return _this.handleMeasure('leftWidth', nativeEvent);\n    };\n    _this._onRightLayout = function (_ref6) {\n      var nativeEvent = _ref6.nativeEvent;\n      return _this.handleMeasure('rightOffset', nativeEvent);\n    };\n    _this.handleMeasure = function (name, nativeEvent) {\n      var _nativeEvent$layout = nativeEvent.layout,\n        width = _nativeEvent$layout.width,\n        x = _nativeEvent$layout.x;\n      switch (name) {\n        case 'rowWidth':\n          _this.rowWidth = width;\n          break;\n        case 'leftWidth':\n          _this.leftWidth = x;\n          break;\n        case 'rightOffset':\n          _this.rightOffset = x;\n          break;\n        default:\n          break;\n      }\n      var leftRender = _this._hasLeftActions ? _this.leftWidth : true;\n      var rightRender = _this._hasRightActions ? _this.rightOffset : true;\n      if (_this.rowWidth && leftRender && rightRender) {\n        _this.setState({\n          rowWidth: _this.rowWidth,\n          leftWidth: _this.leftWidth,\n          rightOffset: _this.rightOffset,\n          measureCompleted: true\n        });\n      }\n    };\n    var _dragX = new Animated.Value(0);\n    _this.rowState = 0;\n    _this.dragThresholdReached = false;\n    _this.state = {\n      dragX: _dragX,\n      rowTranslation: new Animated.Value(0),\n      rowWidth: Constants.screenWidth,\n      leftWidth: undefined,\n      rightOffset: undefined,\n      measureCompleted: false\n    };\n    _this._onGestureEvent = Animated.event([{\n      nativeEvent: {\n        translationX: _dragX\n      }\n    }], {\n      useNativeDriver: props.useNativeAnimations,\n      listener: _this._handleDrag\n    });\n    return _this;\n  }\n  _createClass(Swipeable, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props5 = this.props,\n        children = _this$props5.children,\n        renderLeftActions = _this$props5.renderLeftActions,\n        renderRightActions = _this$props5.renderRightActions,\n        leftActionsContainerStyle = _this$props5.leftActionsContainerStyle,\n        rightActionsContainerStyle = _this$props5.rightActionsContainerStyle,\n        containerStyle = _this$props5.containerStyle,\n        childrenContainerStyle = _this$props5.childrenContainerStyle,\n        testID = _this$props5.testID;\n      var left = this._hasLeftActions && _jsxs(Animated.View, {\n        style: [styles.leftActions, leftActionsContainerStyle, {\n          transform: [{\n            translateX: this.getLeftActionTranslate()\n          }]\n        }],\n        children: [renderLeftActions(this.getShowLeftAction(), this.getTransX()), _jsx(View, {\n          onLayout: this._onLeftLayout\n        })]\n      });\n      var right = this._hasRightActions && _jsxs(Animated.View, {\n        style: [styles.rightActions, rightActionsContainerStyle, {\n          transform: [{\n            translateX: this.getRightActionTranslate()\n          }]\n        }],\n        children: [renderRightActions(this.getShowRightAction(), this.getTransX()), _jsx(View, {\n          onLayout: this._onRightLayout\n        })]\n      });\n      return _jsx(PanGestureHandler, _objectSpread(_objectSpread({}, this.props), {}, {\n        activeOffsetX: [-44, 44],\n        onGestureEvent: this._onGestureEvent,\n        onHandlerStateChange: this._onHandlerStateChange,\n        children: _jsxs(Animated.View, {\n          onLayout: this._onRowLayout,\n          style: [styles.container, containerStyle],\n          children: [left, right, _jsx(TapGestureHandler, {\n            onHandlerStateChange: this._onTapHandlerStateChange,\n            children: _jsx(Animated.View, {\n              style: [{\n                transform: [{\n                  translateX: this.getTransX()\n                }]\n              }, childrenContainerStyle],\n              children: children\n            })\n          })]\n        })\n      }));\n    }\n  }]);\n  return Swipeable;\n}(Component);\nSwipeable.displayName = 'IGNORE';\nSwipeable.defaultProps = {\n  friction: 1,\n  overshootFriction: 1,\n  useNativeAnimations: false,\n  fullLeftThreshold: 0.45,\n  fullRightThreshold: 0.45\n};\nexport { Swipeable as default };\nvar styles = StyleSheet.create({\n  container: {\n    overflow: 'hidden'\n  },\n  leftActions: _objectSpread(_objectSpread({}, StyleSheet.absoluteFillObject), {}, {\n    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row'\n  }),\n  rightActions: _objectSpread(_objectSpread({}, StyleSheet.absoluteFillObject), {}, {\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse'\n  })\n});","map":{"version":3,"names":["React","Component","PanGestureHandler","TapGestureHandler","State","Constants","HapticService","HapticType","DRAG_TOSS","LEFT_TOGGLE_THRESHOLD","Math","sign","x","Number","Swipeable","props","_triggerHaptic","disableHaptic","triggerHaptic","impactMedium","_handleDrag","e","onToggleSwipeLeft","state","rowWidth","leftWidth","nativeEvent","translationX","threshold","dragThresholdReached","dragX","resetItemPosition","getTransX","friction","overshootFriction","rowTranslation","rightOffset","rightWidth","max","overshootLeft","overshootRight","transX","Animated","add","interpolate","inputRange","outputRange","getShowLeftAction","showLeftAction","Value","getLeftActionTranslate","leftActionTranslate","MIN_VALUE","extrapolate","getShowRightAction","showRightAction","getRightActionTranslate","rightActionTranslate","_onTapHandlerStateChange","rowState","oldState","ACTIVE","close","_onHandlerStateChange","_handleRelease","onDragStart","_hasLeftActions","renderLeftActions","undefined","_hasRightActions","renderRightActions","velocityX","fullSwipeLeft","fullSwipeRight","leftThreshold","rightThreshold","fullLeftThreshold","fullRightThreshold","startOffsetX","_currentOffset","toValue","isRTL","_animateRow","fromValue","useNativeAnimations","animationOptions","onSwipeableLeftOpen","onSwipeableRightOpen","onSwipeableClose","onSwipeableOpen","onSwipeableLeftWillOpen","onSwipeableRightWillOpen","onSwipeableWillClose","onSwipeableWillOpen","onFullSwipeLeft","onWillFullSwipeLeft","onFullSwipeRight","onWillFullSwipeRight","setValue","spring","restSpeedThreshold","restDisplacementThreshold","velocity","bounciness","useNativeDriver","start","finished","released","openLeft","openLeftFull","toggleLeft","shouldAnimate","openRight","openRightFull","_onRowLayout","handleMeasure","_onLeftLayout","_onRightLayout","name","layout","width","leftRender","rightRender","setState","measureCompleted","screenWidth","_onGestureEvent","event","listener","children","leftActionsContainerStyle","rightActionsContainerStyle","containerStyle","childrenContainerStyle","testID","left","styles","leftActions","transform","translateX","right","rightActions","container","displayName","defaultProps","StyleSheet","create","overflow","absoluteFillObject","flexDirection","I18nManager"],"sources":["C:/Users/Alex/Documents/development/Rabbit/node_modules/react-native-ui-lib/src/components/drawer/Swipeable.js"],"sourcesContent":["// @ts-nocheck\n// @flow\n// Similarly to the DrawerLayout component this deserves to be put in a\n// separate repo. Although, keeping it here for the time being will allow us\n// to move faster and fix possible issues quicker\n\n// TODO: use Swipeable from react-native-gesture-handler once they support RTL\n\n/* eslint-disable */\nimport React, { Component } from 'react';\nimport { Animated, StyleSheet, View, I18nManager } from 'react-native';\nimport { PanGestureHandler, TapGestureHandler, State } from 'react-native-gesture-handler';\nimport { Constants } from \"../../commons/new\";\nimport { HapticService, HapticType } from \"../../services\";\nconst DRAG_TOSS = 0.05;\nconst LEFT_TOGGLE_THRESHOLD = 0.6;\n\n// Math.sign polyfill for iOS 8.x\nif (!Math.sign) {\n  Math.sign = function (x) {\n    return Number(x > 0) - Number(x < 0) || +x;\n  };\n}\nexport default class Swipeable extends Component {\n  static displayName = 'IGNORE';\n  static defaultProps = {\n    friction: 1,\n    overshootFriction: 1,\n    useNativeAnimations: false,\n    // issue in iPhone5\n    fullLeftThreshold: 0.45,\n    fullRightThreshold: 0.45\n  };\n\n  // _onGestureEvent: ?Animated.Event;\n  // _transX: ?Animated.Interpolation;\n  // _showLeftAction: ?Animated.Interpolation | ?Animated.Value;\n  // _leftActionTranslate: ?Animated.Interpolation;\n  // _showRightAction: ?Animated.Interpolation | ?Animated.Value;\n  // _rightActionTranslate: ?Animated.Interpolation;\n\n  constructor(props) {\n    super(props);\n    const dragX = new Animated.Value(0);\n    // 0 -> open from either left/right,\n    // 1 -> closing to the left\n    // -1 -> closing to the right\n    this.rowState = 0;\n    this.dragThresholdReached = false;\n    this.state = {\n      dragX,\n      rowTranslation: new Animated.Value(0),\n      rowWidth: Constants.screenWidth,\n      leftWidth: undefined,\n      rightOffset: undefined,\n      measureCompleted: false\n    };\n    this._onGestureEvent = Animated.event([{\n      nativeEvent: {\n        translationX: dragX\n      }\n    }], {\n      useNativeDriver: props.useNativeAnimations,\n      listener: this._handleDrag\n    });\n  }\n  _triggerHaptic = () => {\n    return !this.props.disableHaptic && HapticService.triggerHaptic(HapticType.impactMedium, 'Drawer');\n  };\n  _handleDrag = e => {\n    const {\n      onToggleSwipeLeft\n    } = this.props;\n    if (onToggleSwipeLeft) {\n      // Drag left toggle\n      const {\n        rowWidth,\n        leftWidth\n      } = this.state;\n      const x = e.nativeEvent.translationX;\n      const threshold = rowWidth * LEFT_TOGGLE_THRESHOLD;\n      if (!this.dragThresholdReached && x >= threshold && x < threshold + 10) {\n        // move item right\n        this.dragThresholdReached = true;\n        this._triggerHaptic();\n        onToggleSwipeLeft({\n          rowWidth,\n          leftWidth,\n          dragX: x\n        });\n      }\n      if (this.dragThresholdReached && x < threshold - 10) {\n        // move item left\n        this.dragThresholdReached = false;\n        onToggleSwipeLeft({\n          rowWidth,\n          leftWidth,\n          dragX: x,\n          resetItemPosition: true\n        });\n      }\n    }\n  };\n  getTransX = () => {\n    const {\n      friction,\n      overshootFriction\n    } = this.props;\n    const {\n      dragX,\n      rowTranslation,\n      leftWidth = 0,\n      rowWidth = 0\n    } = this.state;\n    const {\n      rightOffset = rowWidth\n    } = this.state;\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\n    const {\n      overshootLeft = leftWidth > 0,\n      overshootRight = rightWidth > 0\n    } = this.props;\n    const transX = Animated.add(rowTranslation, dragX.interpolate({\n      inputRange: [0, friction],\n      outputRange: [0, 1]\n    })).interpolate({\n      inputRange: [-rightWidth - (overshootRight ? 1 : overshootFriction), -rightWidth, leftWidth, leftWidth + (overshootLeft ? 1 : overshootFriction)],\n      outputRange: [-rightWidth - (overshootRight || overshootFriction > 1 ? 1 : 0), -rightWidth, leftWidth, leftWidth + (overshootLeft || overshootFriction > 1 ? 1 : 0)]\n    });\n    return transX;\n  };\n  getShowLeftAction = () => {\n    const transX = this.getTransX();\n    const {\n      leftWidth = 0\n    } = this.state;\n    const showLeftAction = leftWidth > 0 ? transX.interpolate({\n      inputRange: [-1, 0, leftWidth],\n      outputRange: [0, 0, 1]\n    }) : new Animated.Value(0);\n    return showLeftAction;\n  };\n  getLeftActionTranslate = () => {\n    const showLeftAction = this.getShowLeftAction();\n    const leftActionTranslate = showLeftAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp'\n    });\n    return leftActionTranslate;\n  };\n  getShowRightAction = () => {\n    const transX = this.getTransX();\n    const {\n      rowWidth = 0\n    } = this.state;\n    const {\n      rightOffset = rowWidth\n    } = this.state;\n    const rightWidth = Math.max(0, rowWidth - rightOffset);\n    const showRightAction = rightWidth > 0 ? transX.interpolate({\n      inputRange: [-rightWidth, 0, 1],\n      outputRange: [1, 0, 0]\n    }) : new Animated.Value(0);\n    return showRightAction;\n  };\n  getRightActionTranslate = () => {\n    const showRightAction = this.getShowRightAction();\n    const rightActionTranslate = showRightAction.interpolate({\n      inputRange: [0, Number.MIN_VALUE],\n      outputRange: [-10000, 0],\n      extrapolate: 'clamp'\n    });\n    return rightActionTranslate;\n  };\n  _onTapHandlerStateChange = ({\n    nativeEvent\n  }) => {\n    if (this.rowState !== 0) {\n      if (nativeEvent.oldState === State.ACTIVE) {\n        this.close();\n      }\n    }\n  };\n  _onHandlerStateChange = ({\n    nativeEvent\n  }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this._handleRelease(nativeEvent);\n    }\n    if (nativeEvent.state === State.ACTIVE) {\n      this.props.onDragStart && this.props.onDragStart(this.props);\n    }\n  };\n  _hasLeftActions = this.props.renderLeftActions !== undefined;\n  _hasRightActions = this.props.renderRightActions !== undefined;\n  _handleRelease = nativeEvent => {\n    const {\n      velocityX,\n      translationX: dragX\n    } = nativeEvent;\n    const {\n      leftWidth = 0,\n      rowWidth = 0\n    } = this.state;\n    const {\n      rightOffset = rowWidth\n    } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    const {\n      fullSwipeLeft,\n      fullSwipeRight,\n      friction,\n      leftThreshold = leftWidth / 2,\n      rightThreshold = rightWidth / 2,\n      fullLeftThreshold,\n      fullRightThreshold,\n      onToggleSwipeLeft\n    } = this.props;\n    const startOffsetX = this._currentOffset() + dragX / friction;\n    const translationX = (dragX + DRAG_TOSS * velocityX) / friction;\n    let toValue = 0;\n    if (this.rowState === 0) {\n      if (Constants.isRTL && this._hasLeftActions && onToggleSwipeLeft && translationX < -(rowWidth * LEFT_TOGGLE_THRESHOLD) && !this.dragThresholdReached) {\n        // Swipe left toggle RTL\n        toValue = -(rowWidth * LEFT_TOGGLE_THRESHOLD);\n      } else if (this._hasLeftActions && onToggleSwipeLeft && translationX > rowWidth * LEFT_TOGGLE_THRESHOLD && !this.dragThresholdReached) {\n        // Swipe left toggle\n        toValue = rowWidth * LEFT_TOGGLE_THRESHOLD;\n      } else if (!onToggleSwipeLeft && fullSwipeLeft && translationX > rowWidth * fullLeftThreshold) {\n        // Full left swipe\n        this._triggerHaptic();\n        toValue = rowWidth;\n      } else if (this._hasRightActions && fullSwipeRight && translationX < -rowWidth * fullRightThreshold) {\n        // Full right swipe\n        this._triggerHaptic();\n        toValue = -rowWidth;\n      } else if (this._hasLeftActions && translationX > leftThreshold) {\n        // left swipe\n        if (!onToggleSwipeLeft || onToggleSwipeLeft && translationX < rowWidth * LEFT_TOGGLE_THRESHOLD) {\n          // left swipe with toggle\n          toValue = leftWidth;\n        }\n      } else if (this._hasRightActions && translationX < -rightThreshold) {\n        // right swipe\n        toValue = -rightWidth;\n      }\n    } else if (this.rowState === 1) {\n      // swiped to the right (left swipe)\n      if (translationX > -leftThreshold) {\n        toValue = leftWidth;\n      }\n    } else {\n      // swiped to the left (right swipe)\n      if (translationX < rightThreshold) {\n        toValue = -rightWidth;\n      }\n    }\n    this._animateRow(startOffsetX, toValue, velocityX / friction);\n  };\n  _animateRow = (fromValue, toValue, velocityX) => {\n    const {\n      dragX,\n      rowTranslation,\n      rowWidth,\n      leftWidth\n    } = this.state;\n    const {\n      useNativeAnimations,\n      animationOptions,\n      onSwipeableLeftOpen,\n      onSwipeableRightOpen,\n      onSwipeableClose,\n      onSwipeableOpen,\n      onSwipeableLeftWillOpen,\n      onSwipeableRightWillOpen,\n      onSwipeableWillClose,\n      onSwipeableWillOpen,\n      onFullSwipeLeft,\n      onToggleSwipeLeft,\n      onWillFullSwipeLeft,\n      onFullSwipeRight,\n      onWillFullSwipeRight\n    } = this.props;\n    dragX.setValue(0);\n    rowTranslation.setValue(fromValue);\n    this.rowState = Math.sign(toValue);\n    Animated.spring(rowTranslation, {\n      toValue,\n      restSpeedThreshold: 1.7,\n      restDisplacementThreshold: 0.4,\n      velocity: velocityX,\n      bounciness: 0,\n      useNativeDriver: useNativeAnimations,\n      ...animationOptions\n    }).start(({\n      finished\n    }) => {\n      if (finished) {\n        // Final Callbacks\n        if (toValue === rowWidth && onFullSwipeLeft) {\n          onFullSwipeLeft();\n        } else if (toValue === -rowWidth && onFullSwipeRight) {\n          onFullSwipeRight();\n        } else if (toValue > 0 && onSwipeableLeftOpen) {\n          onSwipeableLeftOpen();\n        } else if (toValue < 0 && onSwipeableRightOpen) {\n          onSwipeableRightOpen();\n        }\n        if (toValue === 0) {\n          onSwipeableClose && onSwipeableClose();\n        } else {\n          onSwipeableOpen && onSwipeableOpen();\n        }\n      }\n    });\n\n    // Transition Callbacks\n    if (Constants.isRTL && this._hasLeftActions && onToggleSwipeLeft && (toValue === -(rowWidth * LEFT_TOGGLE_THRESHOLD) || this.dragThresholdReached)) {\n      // left toggle RTL\n      onToggleSwipeLeft({\n        rowWidth,\n        leftWidth,\n        released: true,\n        triggerHaptic: !this.dragThresholdReached\n      });\n    } else if (this._hasLeftActions && onToggleSwipeLeft && (toValue === rowWidth * LEFT_TOGGLE_THRESHOLD || this.dragThresholdReached)) {\n      // left toggle\n      onToggleSwipeLeft({\n        rowWidth,\n        leftWidth,\n        released: true,\n        triggerHaptic: !this.dragThresholdReached\n      });\n      this.dragThresholdReached = false;\n    } else if (toValue === rowWidth && onWillFullSwipeLeft) {\n      onWillFullSwipeLeft();\n    } else if (toValue === -rowWidth && onWillFullSwipeRight) {\n      onWillFullSwipeRight();\n    } else if (toValue > 0 && onSwipeableLeftWillOpen) {\n      onSwipeableLeftWillOpen();\n    } else if (toValue < 0 && onSwipeableRightWillOpen) {\n      onSwipeableRightWillOpen();\n    }\n    if (toValue === 0) {\n      onSwipeableWillClose && onSwipeableWillClose();\n    } else {\n      onSwipeableWillOpen && onSwipeableWillOpen();\n    }\n  };\n  _currentOffset = () => {\n    const {\n      leftWidth = 0,\n      rowWidth = 0\n    } = this.state;\n    const {\n      rightOffset = rowWidth\n    } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    if (this.rowState === 1) {\n      return leftWidth;\n    } else if (this.rowState === -1) {\n      return -rightWidth;\n    }\n    return 0;\n  };\n  close = () => {\n    this._animateRow(this._currentOffset(), 0);\n  };\n  openLeft = () => {\n    const {\n      leftWidth = 0\n    } = this.state;\n    this._animateRow(this._currentOffset(), leftWidth);\n  };\n  openLeftFull = () => {\n    if (this._hasLeftActions) {\n      const {\n        rowWidth\n      } = this.state;\n      this._animateRow(this._currentOffset(), rowWidth);\n    }\n  };\n  toggleLeft = () => {\n    // Programmatically left toggle\n    const shouldAnimate = Constants.isRTL ? this._hasRightActions : this._hasLeftActions;\n    if (shouldAnimate) {\n      const {\n        rowWidth\n      } = this.state;\n      this._animateRow(this._currentOffset(), rowWidth * LEFT_TOGGLE_THRESHOLD * (Constants.isRTL ? -1 : 1));\n    }\n  };\n  openRight = () => {\n    const {\n      rowWidth = 0\n    } = this.state;\n    const {\n      rightOffset = rowWidth\n    } = this.state;\n    const rightWidth = rowWidth - rightOffset;\n    this._animateRow(this._currentOffset(), -rightWidth);\n  };\n  openRightFull = () => {\n    if (this._hasRightActions) {\n      const {\n        rowWidth\n      } = this.state;\n      this._animateRow(this._currentOffset(), -rowWidth);\n    }\n  };\n  _onRowLayout = ({\n    nativeEvent\n  }) => this.handleMeasure('rowWidth', nativeEvent);\n  _onLeftLayout = ({\n    nativeEvent\n  }) => this.handleMeasure('leftWidth', nativeEvent);\n  _onRightLayout = ({\n    nativeEvent\n  }) => this.handleMeasure('rightOffset', nativeEvent);\n  handleMeasure = (name, nativeEvent) => {\n    const {\n      width,\n      x\n    } = nativeEvent.layout;\n    switch (name) {\n      case 'rowWidth':\n        this.rowWidth = width;\n        break;\n      case 'leftWidth':\n        this.leftWidth = x;\n        break;\n      case 'rightOffset':\n        this.rightOffset = x;\n        break;\n      default:\n        break;\n    }\n    const leftRender = this._hasLeftActions ? this.leftWidth : true;\n    const rightRender = this._hasRightActions ? this.rightOffset : true;\n    if (this.rowWidth && leftRender && rightRender) {\n      this.setState({\n        rowWidth: this.rowWidth,\n        leftWidth: this.leftWidth,\n        rightOffset: this.rightOffset,\n        measureCompleted: true\n      });\n    }\n  };\n  render() {\n    const {\n      children,\n      renderLeftActions,\n      renderRightActions,\n      leftActionsContainerStyle,\n      rightActionsContainerStyle,\n      containerStyle,\n      childrenContainerStyle,\n      testID\n    } = this.props;\n    const left = this._hasLeftActions && <Animated.View style={[styles.leftActions, leftActionsContainerStyle, {\n      transform: [{\n        translateX: this.getLeftActionTranslate()\n      }]\n    }]}>\n        {renderLeftActions(this.getShowLeftAction(), this.getTransX())}\n        <View onLayout={this._onLeftLayout} />\n      </Animated.View>;\n    const right = this._hasRightActions && <Animated.View style={[styles.rightActions, rightActionsContainerStyle, {\n      transform: [{\n        translateX: this.getRightActionTranslate()\n      }]\n    }]}>\n        {renderRightActions(this.getShowRightAction(), this.getTransX())}\n        <View onLayout={this._onRightLayout} />\n      </Animated.View>;\n    return <PanGestureHandler {...this.props}\n    // minDeltaX={10}\n    activeOffsetX={[-44, 44]} onGestureEvent={this._onGestureEvent} onHandlerStateChange={this._onHandlerStateChange}>\n        <Animated.View onLayout={this._onRowLayout} style={[styles.container, containerStyle]}>\n          {left}\n          {right}\n          <TapGestureHandler onHandlerStateChange={this._onTapHandlerStateChange}>\n            <Animated.View style={[{\n            transform: [{\n              translateX: this.getTransX()\n            }]\n          }, childrenContainerStyle]}>\n              {children}\n            </Animated.View>\n          </TapGestureHandler>\n        </Animated.View>\n      </PanGestureHandler>;\n  }\n}\nconst styles = StyleSheet.create({\n  container: {\n    overflow: 'hidden'\n  },\n  leftActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL ? 'row-reverse' : 'row'\n  },\n  rightActions: {\n    ...StyleSheet.absoluteFillObject,\n    flexDirection: I18nManager.isRTL ? 'row' : 'row-reverse'\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}