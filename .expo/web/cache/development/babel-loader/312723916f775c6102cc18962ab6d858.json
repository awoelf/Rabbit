{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport React, { useState, useCallback } from 'react';\nimport forwardRef from \"./forwardRef\";\nimport hoistStatics from 'hoist-non-react-statics';\nimport Constants from \"./Constants\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nvar DEFAULT_THRESHOLD = Constants.isAndroid ? 1 : 0;\nfunction withScrollReached(WrappedComponent) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var ScrollReachedDetector = function ScrollReachedDetector(props) {\n    var _useState = useState(true),\n      _useState2 = _slicedToArray(_useState, 2),\n      isScrollAtStart = _useState2[0],\n      setScrollAtStart = _useState2[1];\n    var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isScrollAtEnd = _useState4[0],\n      setScrollAtEnd = _useState4[1];\n    var onScroll = useCallback(function (event) {\n      var _event$nativeEvent = event.nativeEvent,\n        _event$nativeEvent$la = _event$nativeEvent.layoutMeasurement,\n        layoutWidth = _event$nativeEvent$la.width,\n        layoutHeight = _event$nativeEvent$la.height,\n        _event$nativeEvent$co = _event$nativeEvent.contentOffset,\n        offsetX = _event$nativeEvent$co.x,\n        offsetY = _event$nativeEvent$co.y,\n        _event$nativeEvent$co2 = _event$nativeEvent.contentSize,\n        contentWidth = _event$nativeEvent$co2.width,\n        contentHeight = _event$nativeEvent$co2.height;\n      var horizontal = options.horizontal;\n      var threshold = options.threshold || DEFAULT_THRESHOLD;\n      var layoutSize = horizontal ? layoutWidth : layoutHeight;\n      var offset = horizontal ? offsetX : offsetY;\n      var contentSize = horizontal ? contentWidth : contentHeight;\n      if (horizontal && Constants.isRTL && Constants.isAndroid) {\n        var scrollingWidth = Math.max(0, contentSize - layoutSize);\n        offset = scrollingWidth - offset;\n      }\n      var closeToStart = offset <= threshold;\n      if (closeToStart !== isScrollAtStart) {\n        setScrollAtStart(closeToStart);\n      }\n      var closeToEnd = layoutSize + offset >= contentSize - threshold;\n      if (closeToEnd !== isScrollAtEnd) {\n        setScrollAtEnd(closeToEnd);\n      }\n    }, [isScrollAtStart, isScrollAtEnd]);\n    return _jsx(WrappedComponent, _objectSpread(_objectSpread({}, props), {}, {\n      scrollReachedProps: {\n        onScroll: onScroll,\n        isScrollAtStart: isScrollAtStart,\n        isScrollAtEnd: isScrollAtEnd\n      },\n      ref: props.forwardedRef\n    }));\n  };\n  hoistStatics(ScrollReachedDetector, WrappedComponent);\n  ScrollReachedDetector.displayName = WrappedComponent.displayName;\n  ScrollReachedDetector.propTypes = WrappedComponent.propTypes;\n  ScrollReachedDetector.defaultProps = WrappedComponent.defaultProps;\n  return forwardRef(ScrollReachedDetector);\n}\nexport default withScrollReached;","map":{"version":3,"names":["React","useState","useCallback","forwardRef","hoistStatics","Constants","DEFAULT_THRESHOLD","isAndroid","withScrollReached","WrappedComponent","options","ScrollReachedDetector","props","isScrollAtStart","setScrollAtStart","isScrollAtEnd","setScrollAtEnd","onScroll","event","nativeEvent","layoutMeasurement","layoutWidth","width","layoutHeight","height","contentOffset","offsetX","x","offsetY","y","contentSize","contentWidth","contentHeight","horizontal","threshold","layoutSize","offset","isRTL","scrollingWidth","Math","max","closeToStart","closeToEnd","forwardedRef","displayName","propTypes","defaultProps"],"sources":["C:/Users/Alex/Documents/development/Rabbit/node_modules/react-native-ui-lib/src/commons/withScrollReached.js"],"sourcesContent":["import React, { useState, useCallback } from 'react';\nimport forwardRef from \"./forwardRef\";\nimport hoistStatics from 'hoist-non-react-statics';\nimport Constants from \"./Constants\";\nconst DEFAULT_THRESHOLD = Constants.isAndroid ? 1 : 0;\n\n/**\n * @description: Add scroll reached which notifies on reaching start \\ end of ScrollView \\ FlatList\n * @example: https://github.com/wix/react-native-ui-lib/blob/master/demo/src/screens/componentScreens/WithScrollReachedScreen.tsx\n * @notes: Send `props.scrollReachedProps.onScroll` to your onScroll and receive via props.scrollReachedProps.isScrollAtStart props.scrollReachedProps.isScrollAtEnd\n */\nfunction withScrollReached(WrappedComponent, options = {}) {\n  const ScrollReachedDetector = props => {\n    // The scroll starts at the start, from what I've tested this works fine\n    const [isScrollAtStart, setScrollAtStart] = useState(true);\n    const [isScrollAtEnd, setScrollAtEnd] = useState(false);\n    const onScroll = useCallback(event => {\n      const {\n        nativeEvent: {\n          layoutMeasurement: {\n            width: layoutWidth,\n            height: layoutHeight\n          },\n          contentOffset: {\n            x: offsetX,\n            y: offsetY\n          },\n          contentSize: {\n            width: contentWidth,\n            height: contentHeight\n          }\n        }\n      } = event;\n      const horizontal = options.horizontal;\n      const threshold = options.threshold || DEFAULT_THRESHOLD;\n      const layoutSize = horizontal ? layoutWidth : layoutHeight;\n      let offset = horizontal ? offsetX : offsetY;\n      const contentSize = horizontal ? contentWidth : contentHeight;\n      if (horizontal && Constants.isRTL && Constants.isAndroid) {\n        const scrollingWidth = Math.max(0, contentSize - layoutSize);\n        offset = scrollingWidth - offset;\n      }\n      const closeToStart = offset <= threshold;\n      if (closeToStart !== isScrollAtStart) {\n        setScrollAtStart(closeToStart);\n      }\n      const closeToEnd = layoutSize + offset >= contentSize - threshold;\n      if (closeToEnd !== isScrollAtEnd) {\n        setScrollAtEnd(closeToEnd);\n      }\n    }, [isScrollAtStart, isScrollAtEnd]);\n    return <WrappedComponent {...props} scrollReachedProps={{\n      onScroll,\n      isScrollAtStart,\n      isScrollAtEnd\n    }} ref={props.forwardedRef} />;\n  };\n  hoistStatics(ScrollReachedDetector, WrappedComponent);\n  ScrollReachedDetector.displayName = WrappedComponent.displayName;\n  //@ts-ignore\n  ScrollReachedDetector.propTypes = WrappedComponent.propTypes;\n  //@ts-ignore\n  ScrollReachedDetector.defaultProps = WrappedComponent.defaultProps;\n  return forwardRef(ScrollReachedDetector);\n}\nexport default withScrollReached;"],"mappings":";;;;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,WAAW,QAAQ,OAAO;AACpD,OAAOC,UAAU;AACjB,OAAOC,YAAY,MAAM,yBAAyB;AAClD,OAAOC,SAAS;AAAoB;AACpC,IAAMC,iBAAiB,GAAGD,SAAS,CAACE,SAAS,GAAG,CAAC,GAAG,CAAC;AAOrD,SAASC,iBAAiB,CAACC,gBAAgB,EAAgB;EAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;EACvD,IAAMC,qBAAqB,GAAG,SAAxBA,qBAAqB,CAAGC,KAAK,EAAI;IAErC,gBAA4CX,QAAQ,CAAC,IAAI,CAAC;MAAA;MAAnDY,eAAe;MAAEC,gBAAgB;IACxC,iBAAwCb,QAAQ,CAAC,KAAK,CAAC;MAAA;MAAhDc,aAAa;MAAEC,cAAc;IACpC,IAAMC,QAAQ,GAAGf,WAAW,CAAC,UAAAgB,KAAK,EAAI;MACpC,yBAeIA,KAAK,CAdPC,WAAW;QAAA,2CACTC,iBAAiB;QACRC,WAAW,yBAAlBC,KAAK;QACGC,YAAY,yBAApBC,MAAM;QAAA,2CAERC,aAAa;QACRC,OAAO,yBAAVC,CAAC;QACEC,OAAO,yBAAVC,CAAC;QAAA,4CAEHC,WAAW;QACFC,YAAY,0BAAnBT,KAAK;QACGU,aAAa,0BAArBR,MAAM;MAIZ,IAAMS,UAAU,GAAGvB,OAAO,CAACuB,UAAU;MACrC,IAAMC,SAAS,GAAGxB,OAAO,CAACwB,SAAS,IAAI5B,iBAAiB;MACxD,IAAM6B,UAAU,GAAGF,UAAU,GAAGZ,WAAW,GAAGE,YAAY;MAC1D,IAAIa,MAAM,GAAGH,UAAU,GAAGP,OAAO,GAAGE,OAAO;MAC3C,IAAME,WAAW,GAAGG,UAAU,GAAGF,YAAY,GAAGC,aAAa;MAC7D,IAAIC,UAAU,IAAI5B,SAAS,CAACgC,KAAK,IAAIhC,SAAS,CAACE,SAAS,EAAE;QACxD,IAAM+B,cAAc,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAEV,WAAW,GAAGK,UAAU,CAAC;QAC5DC,MAAM,GAAGE,cAAc,GAAGF,MAAM;MAClC;MACA,IAAMK,YAAY,GAAGL,MAAM,IAAIF,SAAS;MACxC,IAAIO,YAAY,KAAK5B,eAAe,EAAE;QACpCC,gBAAgB,CAAC2B,YAAY,CAAC;MAChC;MACA,IAAMC,UAAU,GAAGP,UAAU,GAAGC,MAAM,IAAIN,WAAW,GAAGI,SAAS;MACjE,IAAIQ,UAAU,KAAK3B,aAAa,EAAE;QAChCC,cAAc,CAAC0B,UAAU,CAAC;MAC5B;IACF,CAAC,EAAE,CAAC7B,eAAe,EAAEE,aAAa,CAAC,CAAC;IACpC,OAAO,KAAC,gBAAgB,kCAAKH,KAAK;MAAE,kBAAkB,EAAE;QACtDK,QAAQ,EAARA,QAAQ;QACRJ,eAAe,EAAfA,eAAe;QACfE,aAAa,EAAbA;MACF,CAAE;MAAC,GAAG,EAAEH,KAAK,CAAC+B;IAAa,GAAG;EAChC,CAAC;EACDvC,YAAY,CAACO,qBAAqB,EAAEF,gBAAgB,CAAC;EACrDE,qBAAqB,CAACiC,WAAW,GAAGnC,gBAAgB,CAACmC,WAAW;EAEhEjC,qBAAqB,CAACkC,SAAS,GAAGpC,gBAAgB,CAACoC,SAAS;EAE5DlC,qBAAqB,CAACmC,YAAY,GAAGrC,gBAAgB,CAACqC,YAAY;EAClE,OAAO3C,UAAU,CAACQ,qBAAqB,CAAC;AAC1C;AACA,eAAeH,iBAAiB"},"metadata":{},"sourceType":"module"}